<!DOCTYPE html>
<html lang="he">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>בלוקים קסומים</title>
  <link rel="stylesheet" href="../style/tetris.css">
</head>
<body>
  <header>
    <h1>בלוקים קסומים 🎮</h1>
  </header>

  <main id="game-area">
    <div id="game">
      <canvas id="tetris" width="240" height="400"></canvas>
    </div>

    <section id="hud">
      <div id="scoreboard">
        ניקוד: <span id="score">0</span>
      </div>
      <div id="details">צעדים: <span id="steps">0</span></div>
    </section>

    <section id="controls">
      <button id="startBtn">▶ התחל משחק חדש</button>
    </section>
  </main>

  <script>
  (() => {
    const canvas = document.getElementById('tetris');
    const ctx = canvas.getContext('2d');
    const scoreElem = document.getElementById('score');
    const stepsElem = document.getElementById('steps');
    const startBtn = document.getElementById('startBtn');

    const BLOCK_SIZE = 20, COLS = 12, ROWS = 20;
    const COLORS = [null, '#FF5E5B', '#FFD93D', '#6EFACC', '#FF9CEE', '#FFB347', '#A29BFE', '#7BED9F'];
    const SHAPES = [
      [],
      [[1,1,1],[0,1,0]],
      [[0,2,2],[2,2,0]],
      [[3,3,0],[0,3,3]],
      [[4,0,0],[4,4,4]],
      [[0,0,5],[5,5,5]],
      [[6,6,6,6]],
      [[7,7],[7,7]]
    ];

    class Piece {
      constructor(typeId){
        this.typeId = typeId;
        this.shape = SHAPES[typeId];
        this.pos = { x: Math.floor(COLS/2)-Math.floor(this.shape[0].length/2), y:0 };
      }
      rotate(){
        this.shape = this.shape[0].map((val,i) => this.shape.map(row=>row[i]).reverse());
      }
    }

    const arena = Array.from({length: ROWS}, ()=> new Array(COLS).fill(0));
    let currentPiece = null, score=0, steps=0;
    let dropCounter=0, lastTime=0, dropInterval=1000;

    function drawBlock(x,y,colorId){
      ctx.fillStyle = COLORS[colorId];
      ctx.fillRect(x*BLOCK_SIZE,y*BLOCK_SIZE,BLOCK_SIZE,BLOCK_SIZE);
      ctx.strokeStyle='#222'; ctx.lineWidth=2;
      ctx.strokeRect(x*BLOCK_SIZE,y*BLOCK_SIZE,BLOCK_SIZE,BLOCK_SIZE);
    }

    function draw(){
      ctx.fillStyle='#222';
      ctx.fillRect(0,0,canvas.width,canvas.height);
      arena.forEach((row,y)=>row.forEach((val,x)=>{if(val!==0) drawBlock(x,y,val);}));
      if(currentPiece){
        currentPiece.shape.forEach((row,y)=>row.forEach((val,x)=>{if(val!==0) drawBlock(currentPiece.pos.x+x,currentPiece.pos.y+y,val);}));
      }
    }

    function collide(arena,piece){
      const m = piece.shape, o = piece.pos;
      for(let y=0;y<m.length;y++){
        for(let x=0;x<m[y].length;x++){
          if(m[y][x]!==0 && (arena[y+o.y] && arena[y+o.y][x+o.x])!==0) return true;
        }
      }
      return false;
    }

    function merge(arena,piece){
      piece.shape.forEach((row,y)=>row.forEach((val,x)=>{if(val!==0) arena[y+piece.pos.y][x+piece.pos.x]=val;}));
    }

    function createPiece(){ return new Piece(Math.floor(Math.random()*(SHAPES.length-1))+1); }

    function drop(){
      currentPiece.pos.y++;
      steps++; stepsElem.textContent=steps;
      if(collide(arena,currentPiece)){
        currentPiece.pos.y--;
        merge(arena,currentPiece);
        currentPiece = createPiece();
      }
      dropCounter=0;
    }

    function move(dir){
      currentPiece.pos.x += dir;
      if(collide(arena,currentPiece)) currentPiece.pos.x -= dir;
    }

    function rotatePiece(){
      const posX = currentPiece.pos.x;
      currentPiece.rotate();
      if(collide(arena,currentPiece)){
        currentPiece.rotate(); currentPiece.rotate(); currentPiece.rotate();
        currentPiece.pos.x = posX;
      }
    }

    function update(time=0){
      const deltaTime = time-lastTime;
      lastTime = time;
      dropCounter += deltaTime;
      if(dropCounter > dropInterval) drop();
      draw();
      requestAnimationFrame(update);
    }

    document.addEventListener('keydown', e=>{
      if(!currentPiece) return;
      if(e.key==='ArrowLeft') move(-1);
      else if(e.key==='ArrowRight') move(1);
      else if(e.key==='ArrowDown') drop();
      else if(e.key==='ArrowUp') rotatePiece();
    });

    startBtn.addEventListener('click', ()=>{
      for(let y=0;y<arena.length;y++) arena[y].fill(0);
      score=0; steps=0;
      scoreElem.textContent=score; stepsElem.textContent=steps;
      currentPiece=createPiece();
      dropCounter=0; lastTime=0;
      update();
    });

  })();
  </script>
</body>
</html>
