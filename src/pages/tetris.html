<!-- src/pages/tetris.html -->
<!DOCTYPE html>
<html lang="he">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>בלוקים קסומים</title>
  <link rel="icon" type="image/x-icon" href="../image/favicon.ico">
  <link href="https://fonts.googleapis.com/css2?family=Varela+Round&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="../style/tetris.css">
      <script src="/src/scripts/tetris.js" defer></script>

</head>

<body>
  <header>
    <h1>בלוקים קסומים 🎮</h1>
  </header>

  <!-- משחק -->
  <main id="game-area">
    <div id="game">
      <canvas id="tetris" width="240" height="400"></canvas>
    </div>

    <!-- לוח ניקוד -->
    <section id="hud">
      <div id="scoreboard">
        ניקוד: <span id="score">0</span> | שיא: <span id="highscore">0</span>
      </div>
      <div id="details">צעדים: <span id="steps">0</span></div>
      <div id="levelLabel">רמה: בינוני</div>
    </section>

    <!-- כפתורים -->
    <section id="controls">
      <button id="startBtn">▶ התחל משחק חדש</button>
      <button id="highBtn" onclick="window.location.href='leaderboard.html'">🏆 צפה בשיאים</button>
      <button id="backBtn">⏮ חזרה לדף הכניסה</button>
    </section>
  </main>

  <!-- פופאפ סוף משחק -->
  <div class="popup" id="endPopup">
    <h2 id="popupMessage"></h2>
    <button onclick="document.getElementById('endPopup').style.display='none'">סגור</button>
  </div>

  <!-- אפקט פיצוצים -->
  <div id="confetti-container"></div>
<script>
  //src/scripts/tetris.js
(() => {
  const canvas = document.getElementById('tetris');
  const ctx = canvas.getContext('2d');
  const scoreElem = document.getElementById('score');
  const highscoreElem = document.getElementById('highscore');
  const stepsElem = document.getElementById('steps');
  const startBtn = document.getElementById('startBtn');
  const popup = document.getElementById('endPopup');
  const popupMessage = document.getElementById('popupMessage');
  const confettiContainer = document.getElementById('confetti-container'); // 🎆

  const BLOCK_SIZE = 20, COLS = 12, ROWS = 20;
  const COLORS = [null, '#FF5E5B', '#FFD93D', '#6EFACC', '#FF9CEE', '#FFB347', '#A29BFE', '#7BED9F', '#FF6B81', '#F8EFBA'];
  const SHAPES = [
    [],
    [[1,1,1],[0,1,0]],
    [[0,2,2],[2,2,0]],
    [[3,3,0],[0,3,3]],
    [[4,0,0],[4,4,4]],
    [[0,0,5],[5,5,5]],
    [[6,6,6,6]],
    [[7,7],[7,7]],
    [[0,8,0],[0,8,0]],
    [[9,0,0,0]]
  ];

  class Piece {
    constructor(typeId) {
      this.typeId = typeId;
      this.shape = SHAPES[typeId];
      this.pos = { x: Math.floor(COLS/2)-Math.floor(this.shape[0].length/2), y:0 };
    }
    rotate() {
      this.shape = this.shape[0].map((val,index) =>
        this.shape.map(row => row[index]).reverse()
      );
    }
  }

  const arena = Array.from({ length: ROWS }, () => new Array(COLS).fill(0));
  const userData = JSON.parse(localStorage.getItem('gameUser')) || { level:'medium' };
  let level = userData.level;
  let dropInterval = (level==='hard')?500:1000;

  document.getElementById('levelLabel').textContent = 'Level: ' + (level==='hard'?'Hard':'Medium');

  let currentPiece = null, dropCounter = 0, lastTime = 0, score=0, steps=0;
  let highscore = JSON.parse(localStorage.getItem('tetrisHighscore'))||0;
  highscoreElem.textContent = highscore;
  let gameOver = false, isPaused=false;

  function drawBlock(x,y,colorId){
    ctx.fillStyle = COLORS[colorId];
    ctx.fillRect(x*BLOCK_SIZE,y*BLOCK_SIZE,BLOCK_SIZE,BLOCK_SIZE);
    ctx.strokeStyle = '#222';
    ctx.lineWidth = 2;
    ctx.strokeRect(x*BLOCK_SIZE,y*BLOCK_SIZE,BLOCK_SIZE,BLOCK_SIZE);
  }

  function draw(){
    ctx.fillStyle='#222';
    ctx.fillRect(0,0,canvas.width,canvas.height);
    arena.forEach((row,y)=>row.forEach((val,x)=>{if(val!==0)drawBlock(x,y,val);}));
    if(currentPiece) {
      currentPiece.shape.forEach((row,y)=>row.forEach((val,x)=>{if(val!==0)drawBlock(currentPiece.pos.x+x,currentPiece.pos.y+y,val);}));
    }
  }

  function collide(arena,piece){
    const m=piece.shape, o=piece.pos;
    for(let y=0;y<m.length;y++){
      for(let x=0;x<m[y].length;x++){
        if(m[y][x]!==0 && (arena[y+o.y] && arena[y+o.y][x+o.x])!==0) return true;
      }
    }
    return false;
  }

  function merge(arena,piece){
    piece.shape.forEach((row,y)=>row.forEach((val,x)=>{if(val!==0)arena[y+piece.pos.y][x+piece.pos.x]=val;}));
  }

  // 🎆 פונקציה ליצירת פיצוצים
  function triggerExplosion(rowY) {
    for (let i = 0; i < 25; i++) {
      const particle = document.createElement("span");
      particle.classList.add("particle");

      const size = Math.random() * 8 + 4;
      const angle = Math.random() * 2 * Math.PI;
      const distance = Math.random() * 80 + 40;
      const color = COLORS[Math.floor(Math.random() * (COLORS.length-1)) + 1];

      particle.style.width = `${size}px`;
      particle.style.height = `${size}px`;
      particle.style.background = color;
      particle.style.left = `${canvas.offsetLeft + canvas.width/2}px`;
      particle.style.top = `${canvas.offsetTop + rowY*BLOCK_SIZE}px`;
      particle.style.position = "absolute";
      particle.style.borderRadius = "50%";

      confettiContainer.appendChild(particle);

      particle.animate([
        { transform: "translate(0,0)", opacity: 1 },
        { transform: `translate(${Math.cos(angle) * distance}px, ${Math.sin(angle) * distance}px)`, opacity: 0 }
      ], {
        duration: 1000 + Math.random() * 500,
        easing: "ease-out"
      });

      setTimeout(() => particle.remove(), 1500);
    }
  }

  function sweep(){
    let rowCount=0;
    outer: for(let y=arena.length-1;y>=0;y--){
      if(arena[y].every(val=>val!==0)){
        arena.splice(y,1);
        arena.unshift(new Array(COLS).fill(0));
        rowCount++;
        triggerExplosion(y); // 🎆 אפקט בכל שורה שנמחקת
        y++;
      }
    }
    if(rowCount>0){
      score += rowCount*rowCount*10;
      scoreElem.textContent = score;
      dropInterval = Math.max(100, dropInterval - rowCount*20);
    }
  }

  function createPiece(){ return new Piece(Math.floor(Math.random()*(SHAPES.length-1))+1); }
  function move(dir){ currentPiece.pos.x+=dir; if(collide(arena,currentPiece))currentPiece.pos.x-=dir; }
  function rotatePiece(){ const posX=currentPiece.pos.x; currentPiece.rotate(); if(collide(arena,currentPiece)){currentPiece.rotate();currentPiece.rotate();currentPiece.rotate();currentPiece.pos.x=posX;} }

  function saveGameData(score,steps,level){
    let games = JSON.parse(localStorage.getItem('tetrisGamesHistory'))||[];
    const gameData = { score, steps, level, timestamp: Date.now() };
    games.push(gameData);
    games.sort((a,b)=>b.score-a.score);
    localStorage.setItem('tetrisGamesHistory',JSON.stringify(games));
    localStorage.setItem('tetrisGameData',JSON.stringify(gameData));
  }

  function drop(){
    currentPiece.pos.y++;
    steps++;
    stepsElem.textContent=steps;
    if(collide(arena,currentPiece)){
      currentPiece.pos.y--;
      merge(arena,currentPiece);
      sweep();
      currentPiece=createPiece();
      if(collide(arena,currentPiece)){
        gameOver=true;
        showPopup('Game Over! Score: '+score);
        if(score>highscore){
          localStorage.setItem('tetrisHighscore',JSON.stringify(score));
          highscore=score;
          highscoreElem.textContent=highscore;
          showPopup('New High Score! Score: '+score);
        }
        saveGameData(score,steps,level);
      }
    }
    dropCounter=0;
  }

  function showPopup(message){
    popupMessage.innerText = message;
    popup.style.display='block';
  }

  function update(time=0){
    if(gameOver||isPaused)return;
    const deltaTime = time-lastTime;
    lastTime=time;
    dropCounter+=deltaTime;
    if(dropCounter>dropInterval)drop();
    draw();
    requestAnimationFrame(update);
  }

  document.addEventListener('keydown',e=>{
    if(gameOver||isPaused)return;
    if(e.key==='ArrowLeft') move(-1);
    else if(e.key==='ArrowRight') move(1);
    else if(e.key==='ArrowDown') drop();
    else if(e.key==='ArrowUp') rotatePiece();
  });

  document.getElementById('backBtn').addEventListener('click', () => {
    window.location.href = 'login.html';
  });

  startBtn.addEventListener('click',e=>{
    e.preventDefault();
    for(let y=0;y<arena.length;y++) arena[y].fill(0);
    score=0; steps=0; gameOver=false; isPaused=false; currentPiece=createPiece();
    scoreElem.textContent=0; stepsElem.textContent=0;
    dropInterval=(level==='hard')?500:1000;
    update();
  });

})();

</script>
  <!-- <script src="../scripts/tetris.js"></script> -->

</body>
</html>
